"""Muscle models.

TODO:
- Multiplicative noise option
- Static element (SE) model
- Y and l_eff filters. See `_Y_field` and `_l_eff_field` methods.
    - None of the simplified models I've cited implement these.

:copyright: Copyright 2023-2024 by Matt L Laporte.
:license: Apache 2.0, see LICENSE for details.
"""

from abc import abstractmethod
from collections.abc import Callable
from functools import cached_property
import logging
from typing import Optional, Tuple

import equinox as eqx
from equinox import AbstractVar, field
import jax
import jax.random as jr
import jax.numpy as jnp
from jaxtyping import Array, Float, PRNGKeyArray, PyTree
import numpy as np

from feedbax.dynamics import AbstractDynamicalSystem
from feedbax.state import AbstractState, StateBounds


logger = logging.getLogger(__name__)


class ActivationFilter(AbstractDynamicalSystem):
    """First-order model of the calcium dynamics of muscle activation.

    Attributes:
        tau_act: The activation time constant.
        tau_deact: The deactivation time constant.
    """

    tau_act: float
    tau_deact: float

    # def __init__(
    #     self,
    #     tau_act: float = 50,  # [ms]
    #     tau_deact: float = 66
    # ):
    #     """
    #     Arguments:
    #         tau_act: The activation time constant.
    #         tau_deact: The deactivation time constant.
    #     """
    #     self.tau_act = tau_act
    #     self.tau_deact = tau_deact
    #     self._tau_diff

    def vector_field(
        self,
        t: None,
        state: Array,
        input: Array,
    ):
        """Return the time derivative of activation."""
        activation = state
        tau = self.tau_deact + self._tau_diff * jnp.where(
            input < activation, input, jnp.zeros(1)
        )
        d_activation = (input - activation) / tau

        return d_activation

    @cached_property
    def _tau_diff(self):
        return self.tau_act - self.tau_deact

    def input_size(self):
        return 1

    def init(self):
        raise NotImplementedError("No state PyTree associated with ActivationFilter.")


class AbstractMuscleState(AbstractState):
    """Base class for state PyTrees operated on by muscle models.

    !!! Note
        Typically, muscle state variables are normalized.

    Attributes:
        activation: The muscle activation.
        length: The muscle length.
        velocity: The muscle contraction velocity.
        tension: The tensile force generated by the muscle.
    """

    activation: AbstractVar[Array]
    length: AbstractVar[Array]
    velocity: AbstractVar[Array]
    tension: AbstractVar[Array]


# TODO: maybe `AbstractFLVFunction` and `AbstractActivationFunction` can be joined
class AbstractFLVFunction(eqx.Module):
    """Base class for muscle total force (force-length-velocity) functions."""

    @abstractmethod
    def __call__(self, input: Array, state: AbstractMuscleState) -> Array: ...


class AbstractActivationFunction(eqx.Module):
    """Base class for models that turn muscle input to muscle activation.

    !!! Note
        This is not the same as (say) a first-order filter that approximates
        calcium dynamics, which would be applied to `input` before it arrives
        here.
    """

    @abstractmethod
    def __call__(self, input: Array, state: AbstractMuscleState) -> Array: ...


class AbstractMuscle(eqx.Module):
    """Base class for muscle models.

    Attributes:
        n_muscles: The number of muscles to model. From the perspective of
            this class, the muscles are modeled independently.
        activation_func: The muscle activation function.
        force_func: The muscle force-length-velocity function.
        noise_func: An optional function that adds noise to the muscle force.
    """

    n_muscles: AbstractVar[int]
    activation_func: AbstractVar[AbstractActivationFunction]
    force_func: AbstractVar[AbstractFLVFunction]
    noise_func: AbstractVar[Optional[Callable[[Array, Array, Array], Array]]]

    @jax.named_scope("fbx.AbstractMuscle")
    def __call__(
        self,
        input: Array,
        state: AbstractMuscleState,
        *,
        key: Optional[PRNGKeyArray] = None,
    ) -> AbstractMuscleState:
        """Return state of the muscle, updating the generated force.

        ??? Warning "Difference between 'input' and 'activation'"
            The terms can be a bit confusing, here. The *input* to a real muscle is
            (something like) action potentials acting at a neuromuscular junction,
            which we typically model approximately as a continuous signal
            originating from the controller and passed as `input` to the
            `AbstractPlant` instance.

            The *activation* of the muscle is how much its contractile
            mechanism is activated at a given instant. This depends
            on (for one) the dynamics of the diffusion of calcium ions inside
            the muscle fibre due to the activity at neuromuscular junctions.
            We typically model calcium dynamics with a simple
            first-order filter/dynamics.

            The `input` to `AbstractMuscle.__call__` is usually the muscle's
            *activation*. That's because we need to implement the first-order
            filter for calcium dynamics as part of `dynamics_spec` of the
            `AbstractPlant` instance.

            For example, `MuscledArm` passes `state.activation` to `input`, where
            `state.activation` had been updated on the previous dynamics step
            according to the `ActivationFilter` and the input signals from the
            controller.

            In some cases however, we might omit the `ActivationFilter` and pass
            the controller's output directly through `AbstractPlant` to
            the `input` of this method.

        Arguments:
            input: The activation signal to the muscle.
            state: The prior state of the muscle.
            key: A random key for generating noise in the muscle force.
        """
        activation = self.activation_func(input, state)
        force = self.force_func(activation, state)
        if self.noise_func is not None:
            force = force + self.noise_func(input, force, key)
        return eqx.tree_at(
            lambda state: (state.activation, state.tension),
            state,
            (activation, force),
        )

    def change_n_muscles(self, n_muscles: int) -> "AbstractMuscle":
        """Return a similar model for a different number of muscles."""
        return eqx.tree_at(
            lambda muscle_model: muscle_model.n_muscles,
            self,
            n_muscles,
        )


class VirtualMuscleState(AbstractMuscleState):
    """Type of state PyTree operated on by [`VirtualMuscle`][feedbax.mechanics.muscle.VirtualMuscle]
    instances.

    Attributes:
        activation: The muscle activation.
        length: The muscle length.
        velocity: The muscle contraction velocity.
        tension: The tensile force generated by the muscle.
    """

    activation: Array
    length: Array
    velocity: Array
    tension: Array


class VirtualMuscle(AbstractMuscle):
    """Implements the Virtual Muscle Model from Brown et al. 1999.

    Attributes:
        n_muscles: The number of muscles to model. From the perspective of
            this class, the muscles are modeled independently.
        activation_func: The muscle activation function.
        force_func: The muscle force-length-velocity function.
        noise_func: An optional function that adds noise to the muscle force.
    """

    n_muscles: int
    activation_func: AbstractActivationFunction
    force_func: AbstractFLVFunction
    noise_func: Optional[Callable[[Array, Array, Array], Array]] = None

    def init(self, *, key: Optional[PRNGKeyArray] = None) -> VirtualMuscleState:
        """Return a default state for the model."""
        state = VirtualMuscleState(
            activation=jnp.zeros(self.n_muscles),
            length=jnp.ones(self.n_muscles),
            velocity=jnp.zeros(self.n_muscles),
            tension=None,
        )

        # Calculate tension and return full state.
        return self(state.activation, state, key=key)

    @property
    def bounds(self) -> StateBounds[VirtualMuscleState]:
        """Suggested bounds on the state."""

        # TODO: this would be more general if n_f behaviour is generalized
        # if n_f := getattr(self.activation_func, "n_f", None) is not None:
        if isinstance(self.activation_func, VirtualMuscleActivationFunction):
            n_f = self.activation_func.n_f
            length_ub = 0.95 * n_f[1] / (n_f[1] - n_f[0])
        else:
            length_ub = None

        return StateBounds(
            low=VirtualMuscleState(
                activation=0.0,
                length=None,
                velocity=None,
                tension=None,
            ),
            high=VirtualMuscleState(
                activation=None,
                length=length_ub,
                velocity=None,
                tension=None,
            ),
        )


class AbstractForceFunction(eqx.Module):
    """Base class for muscle force-length, force-velocity, and passive force functions."""

    @abstractmethod
    def __call__(self, length: Array, velocity: Array) -> Array: ...


class VirtualMuscleForceLength(AbstractForceFunction):
    """Force-length function from Brown et al. 1999."""

    beta: float
    omega: float
    rho: float

    def __call__(self, length: Array, velocity: Array) -> Array:
        return jnp.exp(-jnp.abs((length**self.beta - 1) / self.omega) ** self.rho)


class AbstractVirtualMuscleShortenFactor(eqx.Module):
    c_v: Tuple[float, float] = field(converter=tuple)

    @abstractmethod
    def __call__(self, length: Array) -> Array: ...


class VirtualMuscleShortenFactor(AbstractVirtualMuscleShortenFactor):
    """Shortening factor from Brown et al. 1999."""

    def __call__(self, length: Array) -> Array:
        return self.c_v[0] + self.c_v[1] * length


class HillShortenFactor(AbstractVirtualMuscleShortenFactor):
    """Hill-type approximation of the shortening factor."""

    def __call__(self, length: Array) -> Array:
        return self.c_v[0] + self.c_v[1]


class VirtualMuscleForceVelocity(AbstractForceFunction):
    """Force-velocity function from Brown et al. 1999."""

    a_v: Tuple[float, float, float]
    b_v: float
    v_max: float
    shorten_denom_factor_func: AbstractVirtualMuscleShortenFactor

    def __call__(self, length: Array, velocity: Array) -> Array:
        f_lengthen = (
            self.b_v
            - velocity * (self.a_v[0] + self.a_v[1] * length + self.a_v[2] * length**2)
        ) / (self.b_v + velocity)

        f_shorten = (self.v_max - velocity) / (
            self.v_max + velocity * self.shorten_denom_factor_func(length)
        )

        lengthen_idxs = velocity > 0

        return lengthen_idxs * f_lengthen + ~lengthen_idxs * f_shorten


class VirtualMuscleForcePassive1(AbstractForceFunction):
    """Passive force function PE1 from Brown et al. 1999."""

    c1: float
    k1: float
    l_r1: float

    def __call__(self, length: Array, velocity: Array) -> Array:
        return self.c1 * self.k1 * jnp.log(1 + jnp.exp((length - self.l_r1) / self.k1))


class VirtualMuscleForcePassive2(AbstractForceFunction):
    """Passive force function PE2 from Brown et al. 1999."""

    c2: float
    k2: float
    l_r2: float

    def __call__(self, length: Array, velocity: Array) -> Array:
        # TODO: optional Hill approx without l dep
        return self.c2 * jnp.exp(self.k2 * (length - self.l_r2))


class VirtualMuscleActivationFunction(AbstractActivationFunction):
    """Activation for the Virtual Muscle Model (Brown et al. 1999)."""

    a_f: float
    n_f: Tuple[float, float]

    def __call__(self, input: Array, state: AbstractMuscleState) -> Array:
        """Model of the relationship between stimulus frequency `a` and muscle activation.

        The notation may be confusing. The input to this function is sometimes called the
        "activation", hence the name `a`. But this model is based on a muscle being activated
        by stimulation at some frequency by an electrode.
        """
        l_eff = state.length  # TODO: l_eff filter option (see method _l_eff_field)
        n_f = self.n_f[0] + self.n_f[1] * (1 / l_eff - 1)
        Y = 1  # TODO: Y filter option (see method _Y_field)
        A_f = 1 - jnp.exp(-(((input * Y) / (self.a_f * n_f)) ** n_f))
        return A_f


class VirtualMuscleFLVFunction(AbstractFLVFunction):

    force_length: AbstractForceFunction
    force_velocity: AbstractForceFunction
    force_passive_1: AbstractForceFunction
    force_passive_2: AbstractForceFunction

    def __call__(self, input, state: VirtualMuscleState) -> Array:
        force_l = self.force_length(state.length, state.velocity)
        force_v = self.force_velocity(state.length, state.velocity)
        force_pe1 = self.force_passive_1(state.length, state.velocity)
        force_pe2 = self.force_passive_2(state.length, state.velocity)
        # assumes 100% fibre recruitment, linear factor R=1:
        force = input * (force_l * force_v + force_pe2) + force_pe1

        return force


"""Virtual Muscle Model parameters for fast twitch fibers (Brown et al. 1999)."""
BROWN_FAST_TWITCH_VIRTUALMUSCLE_PARAMS = dict(
    force_length=dict(
        beta=1.55,
        omega=0.81,
        rho=2.12,
    ),
    force_velocity=dict(
        a_v=(-1.53, 0.0, 0.0),
        b_v=1.05,
        v_max=-7.39,
    ),
    force_passive_1=dict(
        c1=0.0,
        k1=1.0,  # changed from 0. to avoid div by zero
        l_r1=0.0,
    ),
    force_passive_2=dict(
        c2=-0.02,
        k2=-18.7,
        l_r2=0.79,
    ),
    activation=dict(
        n_f=(2.11, 3.31),
        a_f=0.56,
    ),
    shorten=dict(
        c_v=(-3.21, 4.17),
    ),
    #! unused
    static=dict(
        c_t=27.8,
        k_t=0.0047,
        l_rt=0.964,
    ),
    y_filter=dict(
        tau_y=0.0,  # n/a
        c_y=0.0,
        v_y=0.0,  # n/a
    ),
    l_eff_filter=dict(
        tau_l=0.088,
    ),
)

"""Virtual Muscle Model parameters for slow twitch fibers (Brown et al. 1999)."""
BROWN_SLOW_TWITCH_VIRTUALMUSCLE_PARAMS = dict(
    force_length=dict(
        beta=2.30,
        omega=1.26,
        rho=1.62,
    ),
    force_velocity=dict(
        a_v=(-4.70, 8.41, -5.34),
        b_v=0.18,
        v_max=-4.06,
    ),
    force_passive_1=dict(
        c1=0.0,
        k1=1.0,  # changed from 0. to avoid div by zero
        l_r1=0.0,
    ),
    force_passive_2=dict(
        c2=-0.02,
        k2=-18.7,
        l_r2=0.79,
    ),
    activation=dict(
        n_f=(2.11, 5.0),
        a_f=0.56,
    ),
    shorten=dict(
        c_v=(5.88, 0),
    ),
    #! unused
    static=dict(
        c_t=27.8,
        k_t=0.0047,
        l_rt=0.964,
    ),
    y_filter=dict(
        tau_y=200,  # [ms]
        c_y=0.35,
        v_y=0.1,
    ),
    l_eff_filter=dict(
        tau_l=0.088,
    ),
)


"""Averaged slow- and fast-twitch fiber parameters for the Virtual Muscle Model
(Brown et al. 1999)."""
BROWN_SLOWFAST_AVG_VIRTUALMUSCLE_PARAMS = jax.tree_map(
    lambda x, y: (x + y) / 2,
    BROWN_SLOW_TWITCH_VIRTUALMUSCLE_PARAMS,
    BROWN_FAST_TWITCH_VIRTUALMUSCLE_PARAMS,
)


# Parameters for Todorov & Li 2004 and Lillicrap & Scott 2013 are generally
# some combination of the slow and fast twitch parameters from
# Brown et al. 1999, or averages thereof. This is indicated by comments
# inside the parameter trees.
"""Virtual Muscle Model parameters used by Todorov & Li, 2004."""
TODOROV_LI_VIRTUALMUSCLE_PARAMS = dict(
    force_length=dict(
        beta=1.93,  # slow/fast avg
        omega=1.03,  # slow/fast avg is 1.035
        rho=1.87,  # slow/fast avg
    ),
    force_velocity=dict(
        a_v=(-3.12, 4.21, -2.67),  # slow/fast avg
        b_v=0.62,  # slow/fast avg
        v_max=-5.72,  # slow/fast avg is -5.725
    ),
    force_passive_2=dict(  # identical for slow/fast
        c2=-0.02,
        k2=-18.7,
        l_r2=0.79,
    ),
    shorten=dict(
        c_v=(1.38, 2.09),  # slow/fast avg is (1.335, 2.085)
    ),
    activation=dict(
        n_f=(2.11, 4.16),  # slow/fast avg (2.11, 4.155),
        a_f=0.56,
    ),
    #! unused
    force_passive_1=dict(
        c1=0.0,
        k1=1.0,
        l_r1=0.0,
    ),
)


"""Virtual Muscle Model parameters used by Lillicrap & Scott, 2013."""
LILLICRAP_SCOTT_VIRTUALMUSCLE_PARAMS = dict(
    force_length=dict(
        beta=1.55,  # fast
        omega=0.81,  # fast
        rho=1.0,  # identity exponent; not specified as such
    ),
    force_velocity=dict(
        a_v=(-3.12, 4.21, -2.67),  # slow/fast avg
        b_v=0.62,  # slow/fast avg
        v_max=-7.39,  # fast
    ),
    shorten=dict(
        c_v=(-3.21, 4.17),  # fast
    ),
    #! unused
    force_passive_1=dict(
        c1=0.0,
        k1=1.0,
        l_r1=0.0,
    ),
    force_passive_2=dict(
        c2=0.0,
        k2=0.0,
        l_r2=0.0,
    ),
    activation=dict(
        n_f=0.0,
        a_f=0.0,
    ),
)


def brown_1999_virtualmuscle(
    n_muscles: int = 1,
    noise_func: Optional[Callable] = None,
    params: PyTree[float] = BROWN_SLOWFAST_AVG_VIRTUALMUSCLE_PARAMS,
):
    """Returns a Virtual Muscle Model using the averaged slow/fast twitch
    parameters from Brown et al. 1999.

    Arguments:
        n_muscles: The number of muscles to model.
        noise_func: Generates noise to add to the muscle force.
            Has the signature `noise_func(input, force, key) -> Array`, where
            `input` is the input to the muscle model.
        params: The parameters for the Virtual Muscle Model.
    """
    return VirtualMuscle(
        n_muscles,
        activation_func=VirtualMuscleActivationFunction(**params["activation"]),
        force_func=VirtualMuscleFLVFunction(
            force_length=VirtualMuscleForceLength(**params["force_length"]),
            force_velocity=VirtualMuscleForceVelocity(
                **params["force_velocity"],
                shorten_denom_factor_func=VirtualMuscleShortenFactor(
                    **params["shorten"]
                ),
            ),
            force_passive_1=VirtualMuscleForcePassive1(**params["force_passive_1"]),
            # force_passive_1=lambda length, velocity: 0,
            force_passive_2=VirtualMuscleForcePassive2(**params["force_passive_2"]),
        ),
        noise_func=noise_func,
    )


def todorov_li_2004_virtualmuscle(
    n_muscles: int = 1,
    noise_func: Optional[Callable] = None,
    params: PyTree[float] = TODOROV_LI_VIRTUALMUSCLE_PARAMS,
):
    """Muscle model from Todorov & Li 2004.

    !!! Note ""
        Simplifies the Brown et al. 1999 Virtual Muscle Model:

        1. Omits the first passive element, PE1.
        2. Uses averages of the fast and slow twitch parameters from Brown 1999.

    Arguments:
        n_muscles: The number of muscles to model.
        noise_func: Generates noise to add to the muscle force.
            Has the signature `noise_func(input, force, key) -> Array`, where
            `input` is the input to the muscle model.
        params: The parameters for the Virtual Muscle Model.
    """
    return VirtualMuscle(
        n_muscles,
        activation_func=VirtualMuscleActivationFunction(**params["activation"]),
        force_func=VirtualMuscleFLVFunction(
            force_length=VirtualMuscleForceLength(**params["force_length"]),
            force_velocity=VirtualMuscleForceVelocity(
                **params["force_velocity"],
                shorten_denom_factor_func=VirtualMuscleShortenFactor(
                    **params["shorten"]
                ),
            ),
            force_passive_1=lambda length, velocity: 0,
            force_passive_2=VirtualMuscleForcePassive2(**params["force_passive_2"]),
        ),
        noise_func=noise_func,
    )


class LillicrapScottForceLength(AbstractForceFunction):
    """Force-length function from Lillicrap & Scott 2013 supplement.

    Possibly incorrect. The sign inside the exponential is reversed compared
    to that in Brown et al. 1999 and Todorov & Li 2004.
    """

    beta: float
    omega: float

    def __call__(self, length: Array, velocity: Array) -> Array:
        return jnp.exp(jnp.abs((length**self.beta - 1) / self.omega))


def lillicrap_scott_2013_virtualmuscle(
    n_muscles: int = 1,
    noise_func: Callable = None,
    params: dict = LILLICRAP_SCOTT_VIRTUALMUSCLE_PARAMS,
):
    """Muscle model from Lillicrap & Scott 2013.

    !!! Note ""
        Simplifies the Brown et al. 1999 Virtual Muscle Model:

        1. Uses the Hill approximation (removes denominator `l` dependency)
        for FV shortening.
        2. Omits both passive elements, PE1 and PE2.
        3. Uses the activation directly: `A_f = a`, thus also omits any
        `Y` and `l_eff` filters.
        4. Uses a mixture of fast twitch and averaged slow/fast twitch
        parameters from Brown 1999; see `LILLICRAP_SCOTT_VIRTUALMUSCLE_PARAMS`.

    Arguments:
        n_muscles: The number of muscles to model.
        noise_func: Generates noise to add to the muscle force.
            Has the signature `noise_func(input, force, key) -> Array`, where
            `input` is the input to the muscle model.
        params: The parameters for the Virtual Muscle Model.
    """

    return VirtualMuscle(
        n_muscles,
        activation_func=lambda input, length: input,
        force_func=VirtualMuscleFLVFunction(
            # force_length=LillicrapScottForceLength(params.force_length),
            force_length=VirtualMuscleForceLength(**params["force_length"]),
            force_velocity=VirtualMuscleForceVelocity(
                **params["force_velocity"],
                shorten_denom_factor=HillShortenFactor(**params["shorten"]),
            ),
            force_passive_1=lambda length, velocity: 0,
            force_passive_2=lambda length, velocity: 0,
        ),
        noise_func=noise_func,
    )


#     def _Y_field(self, t, y, args):
#         #! currently unused
#         Y = y
#         v = args
#         c_Y, tau_Y, v_Y = self.c_y, self.tau_y, self.v_y
#         d_Y = 1 - Y - c_Y * (1 - jnp.exp(-jnp.abs(v) / v_Y)) / tau_Y
#         return d_Y

#     def _l_eff_field(self, t, y, args):
#         #! currently unused
#         # TODO: to do this, need to track A_f from last step...
#         l_eff = y
#         l, A_f = args
#         tau_l = self.tau_l
#         d_l_eff = (l - l_eff) ** 3 / (tau_l * (1 - A_f))
#         return d_l_eff
