"""

:copyright: Copyright 2023-2024 by Matt Laporte.
:license: Apache 2.0. See LICENSE for details.
"""

from abc import abstractmethod, abstractproperty
from collections import OrderedDict
from collections.abc import Callable, Mapping, Sequence
from functools import cached_property
import logging
from typing import Generic, Optional, Self, Tuple, Union

import equinox as eqx
from equinox import AbstractVar, Module, field
import jax
from jax import Array
import jax.numpy as jnp
from jaxtyping import Float, PRNGKeyArray, PyTree, Scalar
from feedbax.dynamics import AbstractDynamicalSystem
from feedbax.intervene import AbstractIntervenor
from feedbax.mechanics.muscle import AbstractMuscle, MuscleState
from feedbax.mechanics.skeleton.arm import TwoLinkArm, TwoLinkArmState
from feedbax.mechanics.skeleton.skeleton import AbstractSkeleton, AbstractSkeletonState

from feedbax._staged import AbstractStagedModel, ModelStage
from feedbax.state import StateBounds, StateT, clip_state


logger = logging.getLogger(__name__)


class PlantState(Module, Generic[StateT]):
    """The state of a biomechanical model.

    Some models may only possess a skeleton, with forces input directly by a
    controller.

    Attributes.
        skeleton: The state of the skeleton.
        muscles: The state of the muscles, if included in the model.
    """

    skeleton: StateT
    muscles: Optional[MuscleState] = None


class DynamicsComponent(eqx.Module, Generic[StateT]):
    dynamics: AbstractDynamicalSystem  # [StateS]
    where_input: Callable[[PyTree[Array], StateT], PyTree[Array]]
    where_state: Callable[[StateT], PyTree[Array]]  # returns StateS


class AbstractPlant(
    AbstractStagedModel[PlantState],
    AbstractDynamicalSystem[PlantState],
):
    """Base class for models of muscoloskeletal systems.

    !!! Note ""
        These models describe both 1) the continuous dynamics, and 2) instantaneous
        dependencies between variables.

        For example, we may model 1) the rate of change of skeletal joint angles
        given torques applied to the joints, but also 2) the force generated by
        a muscle, which is not described by a differential equation but is
        directly dependent in each instant on the skeletal geometry.

        Kinematic/geometric updates are specified in `model_spec`, and dynamic updates
        in `dynamics_spec`. Calling an `AbstractPlant` instance will only perform the
        kinematic updates defined in `model_spec`. Normally we wrap the instance in a
        `Mechanics` instance to discretize the dynamics—then, calling the `Mechanics`
        instance will perform both sets of updates.

    Attributes:
        skeleton: The model of skeletal dynamics.
        muscle_model: The muscle model, if the model includes muscles.
        clip_states: Whether to clip the state to its bounds.
    """

    skeleton: AbstractVar[AbstractSkeleton]
    clip_states: AbstractVar[bool]

    def vector_field(
        self, t: Scalar, state: PlantState, input: PyTree[Array]
    ) -> PlantState:
        """Return the time derivatives of musculoskeletal variables,
        where those derivatives are defined.

        !!! Note ""
            Aggregates vector fields for different substates of the plant
            state, as described by `dynamics_spec`.

        Arguments:
            t: The simulation time. Typically this is unused by any of the
                constituent fields.
            state: The state of the musculoskeletal system.
            input: The control inputs to the musculoskeletal system.
        """
        d_state = jax.tree_map(jnp.zeros_like, state)

        for component in self.dynamics_spec.values():
            d_state = eqx.tree_at(
                component.where_state,
                d_state,
                component.dynamics.vector_field(
                    t, component.where_state(state), component.where_input(input, state)
                ),
            )

        return d_state

    @abstractproperty
    def model_spec(self) -> OrderedDict[str, ModelStage[Self, PlantState]]:
        """Specifies kinematic updates to the musculoskeletal state."""
        ...

    @abstractproperty
    def dynamics_spec(self) -> dict[str, DynamicsComponent[PlantState]]:
        """Aggregates differential equations for different substates of the
        musculoskeletal state."""
        ...

    @abstractmethod
    def init(self, *, key: PRNGKeyArray) -> PlantState:
        """Returns a default state for the plant."""
        ...

    @abstractproperty
    def input_size(self) -> int:
        """Number of control inputs."""
        ...

    def _clip_state(self, input, state, *, key: Optional[PRNGKeyArray] = None):
        if self.clip_states:
            return clip_state(input, state)
        else:
            return state


class AbstractMuscledPlant(AbstractPlant):
    muscle_model: AbstractVar[AbstractMuscle]

    @property
    def bounds(self) -> PyTree[StateBounds]:
        """Aggregates the bounds specified by the skeletal and muscle models."""
        return PlantState(
            skeleton=self.skeleton.bounds,
            muscles=self.muscle_model.bounds,
        )


class DirectForceInput(AbstractPlant):
    """Model of a skeleton controlled directly by forces/torques—no muscles.

    !!! Note ""
        This is essentially a wrapper for an `AbstractSkeleton`, it
        skeleton conforms with the interface expected by `Mechanics`.

        It also adds optional state clipping.

    Attributes:
        skeleton: The model of skeletal dynamics.
        muscle_model: None.
        clip_states: Whether to clip the state to its bounds.
        intervenors: Intervenors associated with each model stage.
    """

    skeleton: AbstractSkeleton
    clip_states: bool
    intervenors: Mapping[str, Sequence[AbstractIntervenor]]

    def __init__(
        self,
        skeleton: AbstractSkeleton,
        clip_states: bool = True,
        intervenors: Optional[
            Union[
                Sequence[AbstractIntervenor], Mapping[str, Sequence[AbstractIntervenor]]
            ]
        ] = None,
        *,
        key: Optional[PRNGKeyArray] = None,
    ):
        """
        Arguments:
            skeleton: The model of skeletal dynamics.
            clip_states: Whether to clip the state to its bounds.
            intervenors: Intervenors associated with each model stage.
        """
        self.skeleton = skeleton
        self.clip_states = clip_states
        self.intervenors = self._get_intervenors_dict(intervenors)

    @property
    def model_spec(self) -> OrderedDict[str, ModelStage[Self, PlantState]]:
        """Specifies at most one model stage: state clipping, if it is enabled."""
        Stage = ModelStage[Self, PlantState]

        spec = OrderedDict()

        if self.clip_states:
            spec |= OrderedDict(
                {
                    "clip_skeleton_state": Stage(
                        callable=lambda self: self._clip_state,
                        where_input=lambda input, state: self.bounds.skeleton,
                        where_state=lambda state: state.skeleton,
                    ),
                }
            )

        return spec

    @property
    def dynamics_spec(self) -> dict[str, DynamicsComponent[PlantState]]:
        """Specifies a single dynamical component: the skeleton."""
        return dict(
            {
                "skeleton": DynamicsComponent[PlantState](
                    dynamics=self.skeleton,
                    where_input=lambda input, state: input,
                    where_state=lambda state: state.skeleton,
                ),
            }
        )

    @property
    def memory_spec(self) -> PyTree[bool]:
        """A simple plant has no muscles, and no muscle state to remember."""
        return PlantState(
            skeleton=True,
            muscles=False,
        )

    def init(self, *, key: PRNGKeyArray) -> PlantState:
        """Return a default state for the plant."""
        return PlantState(
            skeleton=self.skeleton.init(key=key),
            muscles=None,
        )

    @property
    def bounds(self) -> PyTree[StateBounds]:
        """Aggregates the bounds specified by the skeletal and muscle models."""
        return PlantState(
            skeleton=self.skeleton.bounds,
        )

    @property
    def input_size(self) -> int:
        """Equal to the skeleton's input size."""
        return self.skeleton.input_size


class MuscledArm(AbstractMuscledPlant):
    """Model of a two-link arm actuated by muscles.

    Attributes:
        skeleton: The model of skeletal dynamics.
        muscle_model: The muscle model.
        activator: The muscle activator, such as
            [`ActivationFilter`][feedbax.mechanics.muscle.ActivationFilter].
        clip_states: Whether to clip the states to their bounds.
        n_muscles: The number of muscles.
        moment_arms: The moment arms of the muscles with respect to the joints.
        theta0: The optimal angles of the muscles with respect to the joints.
        l0: The optimal length for each muscle.
        f0: The maximum isometric force for each muscle.
        intervenors: Intervenors associated with each model stage.
    """

    skeleton: AbstractSkeleton
    muscle_model: AbstractMuscle
    activator: AbstractDynamicalSystem
    clip_states: bool
    n_muscles: int
    moment_arms: Float[Array, "links=2 muscles"]
    theta0: Float[Array, "links=2 muscles"]
    l0: Float[Array, "muscles"]
    f0: Float[Array, "muscles"]
    intervenors: Mapping[str, Sequence[AbstractIntervenor]]

    def __init__(
        self,
        muscle_model: AbstractMuscle,
        activator: AbstractDynamicalSystem,
        skeleton: AbstractSkeleton = TwoLinkArm(),
        clip_states: bool = True,
        moment_arms: Float[Array, "links=2 muscles"] | Sequence[Sequence[float]] = (
            jnp.array(
                (
                    (2.0, -2.0, 0.0, 0.0, 1.50, -2.0),  # [cm]
                    (0.0, 0.0, 2.0, -2.0, 2.0, -1.50),
                )
            )
        ),
        theta0: Float[Array, "links=2 muscles"] | Sequence[Sequence[float]] = (
            2
            * jnp.pi
            * jnp.array(
                (
                    (15.0, 4.88, 0.0, 0.0, 4.5, 2.12),  # [rad]
                    (0.0, 0.0, 80.86, 109.32, 92.96, 91.52),
                )
            )
            / 360.0
        ),
        l0: Float[Array, "muscles"] | Sequence[float] = jnp.array(
            (7.32, 3.26, 6.4, 4.26, 5.95, 4.04)  # [cm]
        ),
        f0: Float[Array, "muscles"] | Sequence[float] = jnp.array(
            (1.0, 1.0, 1.0, 1.0, 1.0, 1.0)  # [N] = [N/cm^2] * [cm^2]
            # 31.8 * jnp.array((22., 12., 18., 14., 5., 10.)),
        ),
        intervenors: Optional[
            Union[
                Sequence[AbstractIntervenor], Mapping[str, Sequence[AbstractIntervenor]]
            ]
        ] = None,
        *,
        key: Optional[PRNGKeyArray] = None,
    ):
        """
        Arguments:
            muscle_model: The muscle model.
            activator: The muscle activator.
            skeleton: The model of skeletal dynamics.
            clip_states: Whether to clip the state to its bounds.
            moment_arms: The moment arms of the muscles with respect to the joints.
            theta0: The optimal angles of the muscles with respect to the joints (radians).
            l0: The optimal length for each muscle.
            f0: The maximum isometric force for each muscle.
            intervenors: Intervenors associated with each model stage.
        """
        self.skeleton = skeleton
        self.activator = activator
        self.clip_states = clip_states

        self.moment_arms = jnp.array(moment_arms)
        self.theta0 = jnp.array(theta0)
        self.l0 = jnp.array(l0)
        self.f0 = jnp.array(f0)
        self.n_muscles = self.moment_arms.shape[1]

        if not self.theta0.shape[1] == self.l0.shape[0] == self.moment_arms.shape[1]:
            raise ValueError(
                "moment_arms, theta0, and l0 must have the same number of "
                "columns (i.e. number of muscles)"
            )
        # Make sure the muscle model has the right number of muscles.
        self.muscle_model = muscle_model.change_n_muscles(self.n_muscles)

        self.intervenors = self._get_intervenors_dict(intervenors)

    @property
    def model_spec(self) -> OrderedDict[str, ModelStage[Self, PlantState]]:
        """Specifies kinematic updates to the musculoskeletal state."""
        Stage = ModelStage[Self, PlantState[TwoLinkArmState]]

        return OrderedDict(
            {
                "clip_skeleton_state": Stage(
                    callable=lambda self: self._clip_state,
                    where_input=lambda input, state: self.bounds.skeleton,
                    where_state=lambda state: state.skeleton,
                ),
                "muscle_geometry": Stage(
                    callable=lambda self: self._muscle_geometry,
                    where_input=lambda input, state: state.skeleton,
                    where_state=lambda state: (
                        state.muscles.length,
                        state.muscles.velocity,
                    ),
                ),
                "clip_muscle_state": Stage(
                    # Activation shouldn't be below 0, and length has an UB.
                    callable=lambda self: self._clip_state,
                    where_input=lambda input, state: self.bounds.muscles,
                    where_state=lambda state: state.muscles,
                ),
                "muscle_tension": Stage(
                    callable=lambda self: self.muscle_model,
                    where_input=lambda input, state: state.muscles.activation,
                    where_state=lambda state: state.muscles,
                ),
                "muscle_torques": Stage(
                    callable=lambda self: self._muscle_torques,
                    where_input=lambda input, state: state.muscles,
                    where_state=lambda state: state.skeleton.torque,
                ),
            }
        )

    @property
    def dynamics_spec(self) -> Mapping[str, DynamicsComponent[PlantState]]:
        """Specifies the components of the muscled arm dynamics."""
        return dict(
            {
                "muscle_activation": DynamicsComponent(
                    dynamics=self.activator,
                    where_input=lambda input, state: input,
                    where_state=lambda state: state.muscles.activation,
                ),
                #! is this applying the torques twice? since arm will do `input_torque + state.torque`
                "skeleton": DynamicsComponent(
                    dynamics=self.skeleton,
                    where_input=lambda input, state: state.skeleton.torque,
                    where_state=lambda state: state.skeleton,
                ),
            }
        )

    def _muscle_geometry(
        self, input: TwoLinkArmState, state: Tuple[Array, Array], *, key=None
    ):
        skeleton_state = input
        length = self._muscle_length(skeleton_state.angle)
        velocity = self._muscle_velocity(skeleton_state.d_angle)

        return (length, velocity)

    def _muscle_length(self, angle: Array) -> Array:
        # TODO: should this be a function? how general is it?
        moment_arms, l0, theta0 = self.moment_arms, self.l0, self.theta0
        l = (
            1
            + (
                moment_arms[0] * (theta0[0] - angle[0])
                + moment_arms[1] * (theta0[1] - angle[1])
            )
            / l0
        )
        return l

    def _muscle_velocity(self, d_angle: Array) -> Array:
        moment_arms, l0 = self.moment_arms, self.l0
        v = (moment_arms[0] * d_angle[0] + moment_arms[1] * d_angle[1]) / l0
        return v

    def _muscle_torques(self, input, state, *, key=None) -> Array:
        torque = self.moment_arms @ (self.f0 * input.tension)
        return torque

    @property
    def memory_spec(self) -> PyTree[bool]:
        return PlantState(
            skeleton=True,
            muscles=True,
        )

    def init(self, *, key: PRNGKeyArray) -> PlantState:
        """Return a default state for the muscled arm."""
        key1, key2 = jax.random.split(key)
        return PlantState(
            skeleton=self.skeleton.init(key=key1),
            muscles=self.muscle_model.init(key=key2),
        )

    @property
    def input_size(self) -> int:
        """Equal to the number of muscles."""
        return self.n_muscles
